// This file is auto-generated by @hey-api/openapi-ts

export const McpServerTypeSchema = {
  type: 'string',
  description: 'MCP Server type',
  enum: ['sse', 'streamable', 'stdio'],
} as const;

export const McpServerDTOSchema = {
  type: 'object',
  required: ['name', 'type', 'enabled', 'isGlobal', 'createdAt', 'updatedAt'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP server name',
      example: 'My MCP Server',
    },
    type: {
      $ref: '#/components/schemas/McpServerType',
    },
    url: {
      type: 'string',
      description: 'MCP server URL (for sse and streamable types)',
      example: 'https://example.com/mcp',
    },
    command: {
      type: 'string',
      description: 'Command to execute (for stdio type)',
      example: 'python',
    },
    args: {
      type: 'array',
      description: 'Command arguments (for stdio type)',
      items: {
        type: 'string',
      },
      example: ['-m', 'server.py'],
    },
    env: {
      type: 'object',
      description: 'Environment variables (for stdio type)',
      additionalProperties: {
        type: 'string',
      },
      example: {
        API_KEY: 'your_api_key',
      },
    },
    headers: {
      type: 'object',
      description: 'HTTP headers (for sse and streamable types)',
      additionalProperties: {
        type: 'string',
      },
      example: {
        Authorization: 'Bearer token',
      },
    },
    reconnect: {
      type: 'object',
      description: 'Reconnection configuration',
      properties: {
        enabled: {
          type: 'boolean',
          description: 'Whether reconnection is enabled',
        },
        maxAttempts: {
          type: 'integer',
          description: 'Maximum number of reconnection attempts',
        },
        delayMs: {
          type: 'integer',
          description: 'Delay between reconnection attempts in milliseconds',
        },
      },
    },
    config: {
      type: 'object',
      description: 'Additional configuration',
      additionalProperties: true,
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the MCP server is enabled',
    },
    isGlobal: {
      type: 'boolean',
      description: 'Whether the MCP server is global',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'MCP server creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'MCP server update time',
    },
  },
} as const;

export const ListMcpServersDataSchema = {
  type: 'object',
  properties: {
    query: {
      type: 'object',
      properties: {
        type: {
          $ref: '#/components/schemas/McpServerType',
        },
        enabled: {
          type: 'boolean',
          description: 'Filter by enabled status',
        },
      },
    },
  },
} as const;

export const ListMcpServersResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/McpServerDTO',
          },
        },
      },
    },
  ],
} as const;

export const UpsertMcpServerRequestSchema = {
  type: 'object',
  required: ['name', 'type'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP server name',
    },
    type: {
      $ref: '#/components/schemas/McpServerType',
    },
    url: {
      type: 'string',
      description: 'MCP server URL (required for sse and streamable types)',
    },
    command: {
      type: 'string',
      description: 'Command to execute (required for stdio type)',
    },
    args: {
      type: 'array',
      description: 'Command arguments (required for stdio type)',
      items: {
        type: 'string',
      },
    },
    env: {
      type: 'object',
      description: 'Environment variables (for stdio type)',
      additionalProperties: {
        type: 'string',
      },
    },
    headers: {
      type: 'object',
      description: 'HTTP headers (for sse and streamable types)',
      additionalProperties: {
        type: 'string',
      },
    },
    reconnect: {
      type: 'object',
      description: 'Reconnection configuration',
      properties: {
        enabled: {
          type: 'boolean',
          description: 'Whether reconnection is enabled',
        },
        maxAttempts: {
          type: 'integer',
          description: 'Maximum number of reconnection attempts',
        },
        delayMs: {
          type: 'integer',
          description: 'Delay between reconnection attempts in milliseconds',
        },
      },
    },
    config: {
      type: 'object',
      description: 'Additional configuration',
      additionalProperties: true,
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the MCP server is enabled',
    },
  },
} as const;

export const UpsertMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/McpServerDTO',
        },
      },
    },
  ],
} as const;

export const DeleteMcpServerRequestSchema = {
  type: 'object',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP name to delete',
    },
  },
} as const;

export const McpServerToolSchema = {
  type: 'object',
  required: ['name', 'description'],
  properties: {
    name: {
      type: 'string',
      description: 'Tool name',
      example: 'tool_name',
    },
    description: {
      type: 'string',
      description: 'Tool description',
      example: 'This tool does something useful',
    },
  },
} as const;

export const ValidateMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/McpServerTool',
          },
        },
      },
    },
  ],
} as const;

export const DeleteMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'null',
        },
      },
    },
  ],
} as const;

export const PageSchema = {
  type: 'object',
  required: ['pageId', 'title', 'createdAt', 'updatedAt'],
  properties: {
    pageId: {
      type: 'string',
      description: 'Page ID',
      example: 'pg-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Page title',
      example: 'My Page',
    },
    description: {
      type: 'string',
      description: 'Page description',
    },
    status: {
      type: 'string',
      description: 'Page status',
      enum: ['draft', 'published'],
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID associated with this page',
      example: 'cv-g30e1b80b5g1itbemc0g5jj3',
    },
    coverUrl: {
      type: 'string',
      description: 'Page cover URL',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Page creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Page last update time',
    },
  },
} as const;

export const PageNodeRelationSchema = {
  type: 'object',
  required: ['relationId', 'nodeId', 'nodeType', 'entityId', 'orderIndex'],
  properties: {
    relationId: {
      type: 'string',
      description: 'Relation ID',
    },
    pageId: {
      type: 'string',
      description: 'Page ID',
    },
    nodeId: {
      type: 'string',
      description: 'Node ID',
    },
    nodeType: {
      type: 'string',
      description: 'Node type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    orderIndex: {
      type: 'integer',
      description: 'Order index',
    },
    nodeData: {
      description: 'Node data',
      $ref: '#/components/schemas/CanvasNodeData',
    },
  },
} as const;

export const PageDetailSchema = {
  type: 'object',
  allOf: [
    {
      $ref: '#/components/schemas/Page',
    },
    {
      type: 'object',
      properties: {
        nodeRelations: {
          type: 'array',
          description: 'List of node relations',
          items: {
            $ref: '#/components/schemas/PageNodeRelation',
          },
        },
        pageConfig: {
          type: 'object',
          description: 'Page configuration',
        },
      },
    },
  ],
} as const;

export const UpdatePageRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Page title',
    },
    description: {
      type: 'string',
      description: 'Page description',
    },
    nodeRelations: {
      type: 'array',
      description: 'List of node relations with updated order',
      items: {
        type: 'object',
        properties: {
          nodeId: {
            type: 'string',
            description: 'Node ID',
          },
          orderIndex: {
            type: 'integer',
            description: 'New order index',
          },
        },
      },
    },
  },
} as const;

export const UpdatePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          allOf: [
            {
              $ref: '#/components/schemas/Page',
            },
            {
              type: 'object',
              properties: {
                nodeRelations: {
                  type: 'array',
                  description: 'List of node relations',
                  items: {
                    $ref: '#/components/schemas/PageNodeRelation',
                  },
                },
              },
            },
          ],
        },
      },
    },
  ],
} as const;

export const DeletePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'ID of the deleted page',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the deleted page',
            },
          },
        },
      },
    },
  ],
} as const;

export const SharePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'Page ID',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the page',
            },
            shareId: {
              type: 'string',
              description: 'Share ID',
            },
            shareUrl: {
              type: 'string',
              description: 'Share URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const DeletePageNodeResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'Page ID',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the page',
            },
            nodeId: {
              type: 'string',
              description: 'ID of the deleted node',
            },
          },
        },
      },
    },
  ],
} as const;

export const ListPagesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            total: {
              type: 'integer',
              description: 'Total number of pages',
            },
            pages: {
              type: 'array',
              description: 'List of pages',
              items: {
                $ref: '#/components/schemas/Page',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const PageDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/PageDetail',
        },
      },
    },
  ],
} as const;

export const AddPageNodesRequestSchema = {
  type: 'object',
  required: ['nodeIds'],
  properties: {
    nodeIds: {
      type: 'array',
      description: 'List of node IDs to add to the page',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const AddPageNodesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            page: {
              $ref: '#/components/schemas/Page',
            },
            nodeRelations: {
              type: 'array',
              description: 'List of node relations',
              items: {
                $ref: '#/components/schemas/PageNodeRelation',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const CanvasPageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            page: {
              $ref: '#/components/schemas/Page',
            },
            nodeRelations: {
              type: 'array',
              description: 'List of node relations',
              items: {
                $ref: '#/components/schemas/PageNodeRelation',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const UserSchema = {
  type: 'object',
  description: 'Refly user, used as JWT payload',
  required: ['uid'],
  properties: {
    uid: {
      type: 'string',
      description: 'UID',
    },
    email: {
      type: 'string',
      description: 'Email',
    },
  },
} as const;

export const ShareUserSchema = {
  type: 'object',
  description: 'Refly user in shared entity',
  required: ['uid'],
  properties: {
    uid: {
      type: 'string',
      description: 'UID',
    },
    name: {
      type: 'string',
      description: 'User name',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
    },
  },
} as const;

export const ListOrderSchema = {
  type: 'string',
  description: 'List order',
  enum: ['creationAsc', 'creationDesc'],
} as const;

export const ReferenceMetaSchema = {
  type: 'object',
  description: 'Reference metadata',
  properties: {
    title: {
      type: 'string',
      description: 'Reference title',
    },
    url: {
      type: 'string',
      description: 'Reference URL',
    },
  },
} as const;

export const BaseReferenceSchema = {
  type: 'object',
  description: 'Basic reference info',
  required: ['sourceType', 'sourceId', 'targetType', 'targetId'],
  properties: {
    sourceType: {
      $ref: '#/components/schemas/ReferenceType',
      description: 'Source entity type',
    },
    sourceId: {
      type: 'string',
      description: 'Source entity ID',
    },
    targetType: {
      $ref: '#/components/schemas/ReferenceType',
      description: 'Target entity type',
    },
    targetId: {
      type: 'string',
      description: 'Target entity ID',
    },
  },
} as const;

export const CanvasStatusSchema = {
  type: 'string',
  description: 'Canvas status',
  enum: ['ready', 'duplicating', 'duplicate_failed'],
} as const;

export const CanvasSchema = {
  type: 'object',
  required: ['canvasId', 'title', 'createdAt', 'updatedAt'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My canvas',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this canvas is read-only',
    },
    status: {
      type: 'string',
      description: 'Canvas status',
      $ref: '#/components/schemas/CanvasStatus',
    },
    minimapUrl: {
      type: 'string',
      description: 'Minimap URL',
    },
    minimapStorageKey: {
      type: 'string',
      description: 'Minimap storage key',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas update time',
    },
  },
} as const;

export const CanvasTemplateCategorySchema = {
  type: 'object',
  required: ['categoryId', 'name', 'labelDict', 'descriptionDict'],
  properties: {
    categoryId: {
      type: 'string',
      description: 'Category ID',
    },
    name: {
      type: 'string',
      description: 'Category name',
    },
    labelDict: {
      type: 'object',
      description: 'Category label dictionary',
      additionalProperties: {
        type: 'string',
      },
    },
    descriptionDict: {
      type: 'object',
      description: 'Category description dictionary',
      additionalProperties: {
        type: 'string',
      },
    },
  },
} as const;

export const CanvasTemplateSchema = {
  type: 'object',
  required: ['templateId', 'shareId', 'title', 'description', 'language', 'createdAt', 'updatedAt'],
  properties: {
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
      example: 'ct-g30e1b80b5g1itbemc0g5jj3',
    },
    shareId: {
      type: 'string',
      description: 'Share ID',
      example: 'can-g30e1b80b5g1itbemc0g5jj3',
    },
    shareUser: {
      description: 'Share user',
      $ref: '#/components/schemas/ShareUser',
    },
    version: {
      type: 'integer',
      description: 'Canvas template version',
    },
    category: {
      description: 'Canvas template category',
      $ref: '#/components/schemas/CanvasTemplateCategory',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
    featured: {
      type: 'boolean',
      description: 'Whether this canvas template is featured',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas template creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas template update time',
    },
  },
} as const;

export const ReferenceSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseReference',
    },
    {
      type: 'object',
      description: 'Reference extra data',
      required: ['referenceId'],
      properties: {
        referenceId: {
          type: 'string',
          description: 'Reference ID',
        },
        sourceMeta: {
          $ref: '#/components/schemas/ReferenceMeta',
          description: 'Source entity metadata',
        },
        targetMeta: {
          $ref: '#/components/schemas/ReferenceMeta',
          description: 'Target entity metadata',
        },
      },
    },
  ],
} as const;

export const ResourceMetaSchema = {
  type: 'object',
  description: 'Resource metadata',
  properties: {
    url: {
      type: 'string',
      description: 'Weblink URL',
      example: 'https://www.google.com',
    },
    title: {
      type: 'string',
      description: 'Weblink title',
      example: 'Google',
    },
    contentType: {
      type: 'string',
      description: 'File content type (MIME type)',
      example: 'application/pdf',
    },
  },
} as const;

export const ResourceTypeSchema = {
  type: 'string',
  description: 'Resource type',
  enum: ['weblink', 'text', 'file'],
} as const;

export const IndexErrorSchema = {
  type: 'object',
  description: 'Error message for resource indexing',
  properties: {
    type: {
      type: 'string',
      description: 'Error type',
      enum: ['pageLimitExceeded', 'unknownError'],
    },
    metadata: {
      type: 'object',
      description: 'Error metadata',
    },
  },
} as const;

export const ResourceSchema = {
  type: 'object',
  required: ['resourceId', 'resourceType', 'title'],
  properties: {
    resourceId: {
      type: 'string',
      description: "Resource ID (empty if it's external)",
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
    resourceType: {
      description: 'Resource type',
      $ref: '#/components/schemas/ResourceType',
    },
    title: {
      type: 'string',
      description: 'Resource title',
    },
    data: {
      type: 'object',
      description: 'Resource metadata',
      $ref: '#/components/schemas/ResourceMeta',
    },
    indexStatus: {
      description: 'Resource index status',
      $ref: '#/components/schemas/IndexStatus',
    },
    indexError: {
      description: 'Error message for resource indexing',
      $ref: '#/components/schemas/IndexError',
    },
    storageSize: {
      type: 'string',
      description: 'Resource storage size (in bytes)',
    },
    vectorSize: {
      type: 'string',
      description: 'Resource vector storage size (in bytes)',
    },
    rawFileKey: {
      type: 'string',
      description: 'Raw file storage key (used to download the file)',
      deprecated: true,
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Resource creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Resource update time',
    },
    contentPreview: {
      type: 'string',
      description: 'Preview content for this resource',
    },
    content: {
      type: 'string',
      description: 'Document content for this resource (only returned in getResourceDetail API)',
    },
    downloadURL: {
      type: 'string',
      description: 'Download URL for this resource (for file type only)',
    },
  },
} as const;

export const ReferenceTypeSchema = {
  type: 'string',
  description: 'Reference type',
  enum: ['document', 'resource'],
} as const;

export const DocumentSchema = {
  type: 'object',
  required: ['docId', 'title'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Document title',
      example: 'My document',
    },
    contentPreview: {
      type: 'string',
      description: 'Document content preview',
    },
    content: {
      type: 'string',
      description: 'Full document content (only returned in detail api)',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this document is read-only',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Document creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Document update time',
    },
  },
} as const;

export const EntityTypeSchema = {
  type: 'string',
  description: 'Entity type',
  enum: [
    'document',
    'resource',
    'canvas',
    'share',
    'user',
    'project',
    'skillResponse',
    'codeArtifact',
    'page',
  ],
} as const;

export const EntitySchema = {
  type: 'object',
  description: 'Entity',
  properties: {
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
  },
} as const;

export const ProjectSourceSchema = {
  type: 'object',
  description: 'Project source',
  properties: {
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
    title: {
      type: 'string',
      description: 'Project title',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project update time',
    },
  },
} as const;

export const ProjectSchema = {
  type: 'object',
  description: 'Project',
  required: ['projectId', 'name'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    name: {
      type: 'string',
      description: 'Project name',
    },
    description: {
      type: 'string',
      description: 'Project description',
    },
    coverUrl: {
      type: 'string',
      description: 'Project cover URL',
    },
    customInstructions: {
      type: 'string',
      description: 'Custom instructions for the project',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project update time',
    },
  },
} as const;

export const LabelClassSchema = {
  type: 'object',
  description: 'Label class',
  required: ['labelClassId', 'name', 'displayName', 'createdAt', 'updatedAt'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'Related Dataset',
    },
    displayName: {
      type: 'string',
      description: 'Label class display name',
      example: 'Label display name',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Label class creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Label class update time',
    },
  },
} as const;

export const LabelInstanceSchema = {
  type: 'object',
  description: 'Label instances related to entities',
  required: ['labelId', 'labelClassId', 'value'],
  properties: {
    labelId: {
      type: 'string',
      description: 'Label instance ID',
      example: 'lb-g30e1b80b5g1itbemc0g5jj3',
    },
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    labelClass: {
      description: 'Label class',
      $ref: '#/components/schemas/LabelClass',
    },
    value: {
      type: 'string',
      description: 'Label value',
      example: 'HotPotQA',
    },
  },
} as const;

export const InputModeSchema = {
  type: 'string',
  description: 'Data input mode',
  enum: ['input', 'inputNumber', 'inputTextArea', 'select', 'multiSelect', 'radio', 'switch'],
} as const;

export const ConfigScopeSchema = {
  type: 'array',
  description: 'Config scope',
  items: {
    type: 'string',
    enum: ['runtime', 'template'],
  },
} as const;

export const SelectOptionSchema = {
  type: 'object',
  description: 'Select option',
  required: ['value'],
  properties: {
    value: {
      type: 'string',
      description: 'Option value',
    },
    labelDict: {
      type: 'object',
      description: 'Option label (key is locale, value is label)',
      additionalProperties: {
        type: 'string',
      },
    },
    disabled: {
      type: 'boolean',
      description: 'Whether this option is disabled',
      default: false,
    },
  },
} as const;

export const DynamicConfigItemSchema = {
  type: 'object',
  description: 'Dynamic config item',
  required: ['key', 'inputMode', 'labelDict', 'descriptionDict'],
  properties: {
    key: {
      type: 'string',
      description: 'Config key',
    },
    inputMode: {
      description: 'Config input mode',
      $ref: '#/components/schemas/InputMode',
    },
    required: {
      type: 'object',
      description: 'Specifies whether this config is required and in which contexts',
      properties: {
        value: {
          type: 'boolean',
          description: 'Whether this config is required',
          default: false,
        },
        configScope: {
          description: 'The contexts in which the requirement applies',
          $ref: '#/components/schemas/ConfigScope',
        },
      },
      default: {
        value: false,
        scope: ['runtime', 'template'],
      },
    },
    labelDict: {
      type: 'object',
      description: 'Config label (key is locale, value is label)',
      additionalProperties: {
        type: 'string',
      },
    },
    descriptionDict: {
      type: 'object',
      description: 'Config description (key is locale, value is description)',
      additionalProperties: {
        type: 'string',
      },
    },
    defaultValue: {
      description: 'Default value',
      oneOf: [
        {
          type: 'number',
        },
        {
          type: 'string',
        },
        {
          type: 'boolean',
        },
        {
          type: 'array',
          items: {
            type: 'string',
          },
        },
      ],
    },
    options: {
      type: 'array',
      description: 'Config options',
      items: {
        $ref: '#/components/schemas/SelectOption',
      },
    },
    inputProps: {
      type: 'object',
      description: 'Additional input properties',
      properties: {
        min: {
          type: 'number',
          description: 'Minimum value for number input',
        },
        max: {
          type: 'number',
          description: 'Maximum value for number input',
        },
        step: {
          type: 'number',
          description: 'Step value for number input',
        },
        precision: {
          type: 'number',
          description: 'Decimal precision for number input',
        },
        passwordType: {
          type: 'boolean',
          description: 'Whether to display as password input',
        },
      },
    },
  },
} as const;

export const DynamicConfigValueSchema = {
  type: 'object',
  description: 'Dynamic config value',
  required: ['label', 'value', 'displayValue'],
  properties: {
    label: {
      type: 'string',
      description: 'Config key label',
    },
    value: {
      oneOf: [
        {
          type: 'string',
        },
        {
          type: 'number',
        },
        {
          type: 'boolean',
        },
        {
          type: 'array',
          items: {
            type: 'string',
          },
        },
        {
          type: 'object',
          additionalProperties: true,
        },
      ],
      description: 'Config value',
    },
    displayValue: {
      type: 'string',
      description: 'Config display value',
    },
    configScope: {
      description: 'The contexts in which the requirement applies',
      $ref: '#/components/schemas/ConfigScope',
    },
  },
} as const;

export const SkillTemplateConfigDefinitionSchema = {
  type: 'object',
  description: 'Skill template config schema',
  required: ['items'],
  properties: {
    items: {
      type: 'array',
      description: 'Config items',
      items: {
        $ref: '#/components/schemas/DynamicConfigItem',
      },
    },
  },
} as const;

export const IconTypeSchema = {
  type: 'string',
  description: 'Icon type',
  enum: ['emoji', 'image'],
} as const;

export const IconSchema = {
  type: 'object',
  description: 'Icon',
  required: ['type', 'value'],
  properties: {
    type: {
      description: 'Icon type',
      $ref: '#/components/schemas/IconType',
    },
    value: {
      type: 'string',
      description: 'Icon value',
    },
  },
} as const;

export const SkillSchema = {
  type: 'object',
  description: 'Skill',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Skill name',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill icon',
      $ref: '#/components/schemas/Icon',
    },
    configSchema: {
      description: 'Skill config schema',
      $ref: '#/components/schemas/SkillTemplateConfigDefinition',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const SkillTriggerTypeSchema = {
  type: 'string',
  description: 'Skill trigger type',
  enum: ['timer', 'simpleEvent'],
} as const;

export const SimpleEventNameSchema = {
  type: 'string',
  description: 'Simple event name',
  enum: ['onResourceReady'],
} as const;

export const SimpleEventSchema = {
  type: 'object',
  required: ['name', 'displayName', 'provideContextKeys'],
  properties: {
    name: {
      description: 'Simple event name',
      $ref: '#/components/schemas/SimpleEventName',
    },
    displayName: {
      type: 'object',
      description: 'Simple event display name (key is locale, value is display name)',
    },
    provideContextKeys: {
      type: 'array',
      description: 'Context keys to provide',
      items: {
        $ref: '#/components/schemas/SkillContextKey',
      },
    },
  },
} as const;

export const TimerIntervalSchema = {
  type: 'string',
  description: 'Timer interval',
  enum: ['hour', 'day', 'week', 'month', 'year'],
} as const;

export const TimerTriggerConfigSchema = {
  type: 'object',
  required: ['datetime'],
  properties: {
    datetime: {
      type: 'string',
      format: 'date-time',
      description: 'Time to run',
    },
    repeatInterval: {
      type: 'string',
      description: 'Repeat interval',
      $ref: '#/components/schemas/TimerInterval',
    },
  },
} as const;

export const SkillTriggerSchema = {
  type: 'object',
  description: 'Skill triggers',
  required: [
    'skillId',
    'displayName',
    'triggerId',
    'triggerType',
    'enabled',
    'createdAt',
    'updatedAt',
  ],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 'sk-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Trigger display name',
      example: 'My trigger',
    },
    triggerId: {
      type: 'string',
      description: 'Trigger ID',
      example: 'tr-g30e1b80b5g1itbemc0g5jj3',
    },
    triggerType: {
      description: 'Trigger type',
      $ref: '#/components/schemas/SkillTriggerType',
    },
    simpleEventName: {
      description: 'Simple event name (only required when trigger type is `simpleEvent`)',
      $ref: '#/components/schemas/SimpleEventName',
    },
    timerConfig: {
      description: 'Timer config (only required when trigger type is `timer`)',
      $ref: '#/components/schemas/TimerTriggerConfig',
    },
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    context: {
      description: 'Skill context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
    enabled: {
      type: 'boolean',
      description: 'Trigger enabled',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Trigger creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Trigger update time',
    },
  },
} as const;

export const SkillMetaSchema = {
  type: 'object',
  description: 'Skill metadata',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Skill name',
    },
    icon: {
      description: 'Skill icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const ActionMetaSchema = {
  type: 'object',
  description: 'Action metadata',
  properties: {
    type: {
      type: 'string',
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    name: {
      type: 'string',
      description: 'Action name',
    },
    icon: {
      description: 'Action icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const SkillRuntimeConfigSchema = {
  type: 'object',
  description: 'Skill runtime config',
  properties: {
    disableLinkParsing: {
      type: 'boolean',
      description: 'Whether to disable link parsing for input query',
    },
    enabledKnowledgeBase: {
      type: 'boolean',
      description: 'Whether to enable knowledge base for input query',
    },
  },
} as const;

export const SkillTemplateConfigSchema = {
  type: 'object',
  description: 'Skill template config (key is config item key, value is config value)',
  additionalProperties: {
    description: 'Skill template config value',
    $ref: '#/components/schemas/DynamicConfigValue',
  },
} as const;

export const ActionConfigSchema = {
  type: 'object',
  description: 'Action config (key is config item key, value is config value)',
  additionalProperties: {
    description: 'Skill template config value',
    $ref: '#/components/schemas/DynamicConfigValue',
  },
} as const;

export const SkillInstanceSchema = {
  type: 'object',
  description: 'Skill',
  allOf: [
    {
      $ref: '#/components/schemas/SkillMeta',
    },
    {
      type: 'object',
      required: ['createdAt', 'updatedAt', 'invocationConfig'],
      properties: {
        description: {
          type: 'string',
          description: 'Skill instance description',
        },
        promptHint: {
          type: 'string',
          description: 'Skill instance prompt hint',
        },
        tplConfig: {
          description: 'Skill template config',
          $ref: '#/components/schemas/SkillTemplateConfig',
        },
        tplConfigSchema: {
          description: 'Skill template config schema',
          $ref: '#/components/schemas/SkillTemplateConfigDefinition',
        },
        invocationConfig: {
          description: 'Skill invocation config',
          $ref: '#/components/schemas/SkillInvocationConfig',
        },
        pinnedAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill pinned time',
        },
        createdAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill creation time',
        },
        updatedAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill update time',
        },
      },
    },
  ],
} as const;

export const SourceMetaSchema = {
  type: 'object',
  description: 'Source metadata',
  properties: {
    source: {
      type: 'string',
      description: 'Source URL',
      deprecated: true,
    },
    title: {
      type: 'string',
      description: 'Source title',
      deprecated: true,
    },
    publishedTime: {
      type: 'string',
      format: 'date-time',
      description: 'Source publish timesss',
    },
    entityId: {
      type: 'string',
      description: 'Related entity ID',
    },
    entityType: {
      type: 'string',
      description: 'Related entity type',
    },
    originalLocale: {
      type: 'string',
      description: 'Original locale',
    },
    translatedDisplayLocale: {
      type: 'string',
      description: 'Translated display locale',
    },
    isTranslated: {
      type: 'boolean',
      description: 'Whether the source is translated',
    },
    originalQuery: {
      type: 'string',
      description: 'Original query',
    },
    translatedQuery: {
      type: 'string',
      description: 'Translated query',
    },
    sourceType: {
      type: 'string',
      description: 'Source type',
      enum: ['webSearch', 'library'],
    },
  },
} as const;

export const SourceSelectionSchema = {
  type: 'object',
  description: 'Source selection',
  required: ['content', 'type'],
  properties: {
    xPath: {
      type: 'string',
      description: 'Selected xPath',
      deprecated: true,
    },
    content: {
      type: 'string',
      description: 'Selected content',
    },
    type: {
      type: 'string',
      description: 'Selection type',
      enum: ['text', 'table', 'link', 'image', 'video', 'audio'],
    },
  },
} as const;

export const SourceSchema = {
  type: 'object',
  description: 'Source of the message',
  required: ['pageContent'],
  properties: {
    url: {
      type: 'string',
      description: 'Source URL',
    },
    title: {
      type: 'string',
      description: 'Source title',
    },
    pageContent: {
      type: 'string',
      description: 'Source content',
    },
    score: {
      type: 'number',
      description: 'Relativity score',
    },
    metadata: {
      type: 'object',
      description: 'Source metadata',
      $ref: '#/components/schemas/SourceMeta',
    },
    selections: {
      type: 'array',
      description: 'Source selections',
      items: {
        $ref: '#/components/schemas/SourceSelection',
      },
    },
  },
} as const;

export const SearchStepSchema = {
  type: 'object',
  description: 'Search step',
  properties: {
    step: {
      type: 'string',
      description: 'Search step name',
    },
    duration: {
      type: 'number',
      description: 'Step duration in milliseconds',
    },
    result: {
      type: 'object',
      description: 'Step-specific result data',
    },
  },
} as const;

export const ModelTierSchema = {
  type: 'string',
  description: 'Model tier',
  enum: ['t1', 't2', 'free'],
} as const;

export const TokenUsageItemSchema = {
  type: 'object',
  description: 'Token usage item',
  required: ['modelName', 'modelProvider', 'inputTokens', 'outputTokens'],
  properties: {
    modelName: {
      type: 'string',
      description: 'Model name',
    },
    modelProvider: {
      type: 'string',
      description: 'Model provider',
    },
    inputTokens: {
      type: 'number',
      description: 'Input tokens',
    },
    outputTokens: {
      type: 'number',
      description: 'Output tokens',
    },
    tier: {
      type: 'string',
      description: 'Model tier',
    },
  },
} as const;

export const ActionStatusSchema = {
  type: 'string',
  description: 'Action status',
  enum: ['waiting', 'executing', 'finish', 'failed'],
} as const;

export const ArtifactTypeSchema = {
  type: 'string',
  description: 'Artifact type',
  enum: ['document', 'codeArtifact'],
} as const;

export const ArtifactStatusSchema = {
  type: 'string',
  description: 'Artifact status',
  enum: ['waiting', 'generating', 'finish', 'failed'],
} as const;

export const ArtifactSchema = {
  type: 'object',
  description: 'Artifact',
  required: ['type', 'entityId', 'title'],
  properties: {
    type: {
      type: 'string',
      description: 'Artifact type',
      $ref: '#/components/schemas/ArtifactType',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    title: {
      type: 'string',
      description: 'Artifact title',
    },
    status: {
      description: 'Artifact status',
      $ref: '#/components/schemas/ArtifactStatus',
    },
    content: {
      type: 'string',
      description: 'Artifact content',
    },
    metadata: {
      type: 'object',
      description: 'Artifact metadata',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Artifact creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Artifact update time',
    },
  },
} as const;

export const ActionStepMetaSchema = {
  type: 'object',
  description: 'Action step metadata',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Step name',
    },
  },
} as const;

export const ActionLogSchema = {
  type: 'object',
  description: 'Action log',
  required: ['key'],
  properties: {
    key: {
      type: 'string',
      description: 'Log key',
    },
    titleArgs: {
      type: 'object',
      description: 'Log title arguments',
    },
    descriptionArgs: {
      type: 'object',
      description: 'Log description arguments',
    },
  },
} as const;

export const ActionStepSchema = {
  type: 'object',
  description: 'Action step',
  required: ['name', 'status'],
  properties: {
    name: {
      type: 'string',
      description: 'Step name',
    },
    content: {
      type: 'string',
      description: 'Step content',
    },
    reasoningContent: {
      type: 'string',
      description: 'Step reasoning content',
    },
    artifacts: {
      type: 'array',
      description: 'Step artifacts',
      items: {
        $ref: '#/components/schemas/Artifact',
      },
    },
    structuredData: {
      type: 'object',
      description: 'Step structured data output',
      example: {
        sources: ['Source'],
        relatedQuestions: ['string'],
      },
    },
    logs: {
      type: 'array',
      description: 'Action step logs',
      items: {
        $ref: '#/components/schemas/ActionLog',
      },
    },
    tokenUsage: {
      type: 'array',
      description: 'Token usage',
      items: {
        $ref: '#/components/schemas/TokenUsageItem',
      },
    },
  },
} as const;

export const CodeArtifactTypeSchema = {
  type: 'string',
  description: 'Code artifact type',
  enum: [
    'application/refly.artifacts.react',
    'image/svg+xml',
    'application/refly.artifacts.mermaid',
    'text/markdown',
    'application/refly.artifacts.code',
    'text/html',
    'application/refly.artifacts.mindmap',
  ],
} as const;

export const CodeArtifactSchema = {
  type: 'object',
  description: 'Code artifact',
  required: ['type', 'artifactId', 'title'],
  properties: {
    type: {
      type: 'string',
      description: 'Artifact type',
      $ref: '#/components/schemas/CodeArtifactType',
    },
    artifactId: {
      type: 'string',
      description: 'Artifact ID',
    },
    title: {
      type: 'string',
      description: 'Artifact title',
    },
    content: {
      type: 'string',
      description: 'Code artifact content',
    },
    language: {
      type: 'string',
      description: 'Code artifact language',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
    },
  },
} as const;

export const ActionResultSchema = {
  type: 'object',
  description: 'Action result',
  required: ['resultId'],
  properties: {
    resultId: {
      type: 'string',
      readOnly: true,
      description: 'Action result ID',
      example: 'ar-g30e1b80b5g1itbemc0g5jj3',
    },
    version: {
      type: 'number',
      description: 'Action result version',
    },
    title: {
      type: 'string',
      description: 'Action result title',
    },
    input: {
      description: 'Action input',
      $ref: '#/components/schemas/SkillInput',
    },
    tier: {
      description: 'Model tier',
      $ref: '#/components/schemas/ModelTier',
    },
    status: {
      type: 'string',
      description: 'Step status',
      $ref: '#/components/schemas/ActionStatus',
    },
    type: {
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    modelInfo: {
      description: 'Selected model',
      $ref: '#/components/schemas/ModelInfo',
    },
    targetType: {
      description: 'Action target type',
      $ref: '#/components/schemas/EntityType',
    },
    targetId: {
      type: 'string',
      description: 'Action target ID',
    },
    actionMeta: {
      type: 'object',
      description: 'Action metadata',
      $ref: '#/components/schemas/ActionMeta',
    },
    context: {
      type: 'object',
      description: 'Action context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      type: 'object',
      description: 'Action template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
    runtimeConfig: {
      type: 'object',
      description: 'Action runtime config',
      $ref: '#/components/schemas/SkillRuntimeConfig',
    },
    history: {
      type: 'array',
      description: 'Action result history',
      items: {
        $ref: '#/components/schemas/ActionResult',
      },
    },
    steps: {
      type: 'array',
      description: 'Action steps',
      items: {
        $ref: '#/components/schemas/ActionStep',
      },
    },
    errors: {
      type: 'array',
      description: 'Errors',
      items: {
        type: 'string',
      },
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Message creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Message update time',
    },
  },
} as const;

export const IndexStatusSchema = {
  type: 'string',
  description: 'Resource index status',
  enum: ['init', 'wait_parse', 'wait_index', 'finish', 'parse_failed', 'index_failed'],
} as const;

export const SubscriptionIntervalSchema = {
  type: 'string',
  description: 'Payment recurring interval',
  enum: ['monthly', 'yearly'],
} as const;

export const SubscriptionPlanTypeSchema = {
  type: 'string',
  description: 'Subscription plan type',
  enum: ['free', 'plus', 'pro', 'max', 'ultra'],
} as const;

export const SubscriptionStatusSchema = {
  type: 'string',
  description: 'Subscription status',
  enum: [
    'active',
    'canceled',
    'incomplete',
    'incomplete_expired',
    'past_due',
    'paused',
    'trialing',
    'unpaid',
  ],
} as const;

export const SubscriptionSchema = {
  type: 'object',
  required: ['subscriptionId', 'planType', 'status'],
  properties: {
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    planType: {
      type: 'string',
      description: 'Subscription plan type',
      $ref: '#/components/schemas/SubscriptionPlanType',
    },
    interval: {
      description: 'Payment recurring interval',
      $ref: '#/components/schemas/SubscriptionInterval',
    },
    status: {
      type: 'string',
      description: 'Subscription status',
      $ref: '#/components/schemas/SubscriptionStatus',
    },
    isTrial: {
      type: 'boolean',
      description: 'Whether the subscription is a trial',
    },
    cancelAt: {
      type: 'string',
      format: 'date-time',
      description: 'Subscription cancel time',
    },
  },
} as const;

export const TokenUsageMeterSchema = {
  type: 'object',
  required: [
    'meterId',
    'uid',
    'startAt',
    't1TokenQuota',
    't1TokenUsed',
    't2TokenQuota',
    't2TokenUsed',
  ],
  properties: {
    meterId: {
      type: 'string',
      description: 'Token usage meter ID',
    },
    uid: {
      type: 'string',
      description: 'User ID',
    },
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    startAt: {
      type: 'string',
      format: 'date-time',
      description: 'Token usage meter start time',
    },
    endAt: {
      type: 'string',
      format: 'date-time',
      description: 'Token usage meter end time',
    },
    t1CountQuota: {
      type: 'number',
      description: 'Request count quota (T1)',
      example: 1000000,
    },
    t1CountUsed: {
      type: 'number',
      description: 'Request count used (T1)',
      example: 100000,
    },
    t1TokenQuota: {
      type: 'number',
      description: 'Token quota (T1)',
      example: 1000000,
      deprecated: true,
    },
    t1TokenUsed: {
      type: 'number',
      description: 'Token used (T1)',
      example: 100000,
      deprecated: true,
    },
    t2CountQuota: {
      type: 'number',
      description: 'Request count quota (T2)',
      example: 1000000,
    },
    t2CountUsed: {
      type: 'number',
      description: 'Request count used (T2)',
      example: 100000,
    },
    t2TokenQuota: {
      type: 'number',
      description: 'Token quota (T2)',
      example: 1000000,
      deprecated: true,
    },
    t2TokenUsed: {
      type: 'number',
      description: 'Token used (T2)',
      example: 100000,
      deprecated: true,
    },
  },
} as const;

export const StorageUsageMeterSchema = {
  type: 'object',
  required: [
    'meterId',
    'uid',
    'objectStorageQuota',
    'resourceSize',
    'canvasSize',
    'fileSize',
    'vectorStorageQuota',
    'vectorStorageUsed',
  ],
  properties: {
    meterId: {
      type: 'string',
      description: 'Storage usage meter ID',
    },
    uid: {
      type: 'string',
      description: 'User ID',
    },
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    fileCountUsed: {
      type: 'number',
      description: 'File count used',
      example: 100,
    },
    fileCountQuota: {
      type: 'number',
      description: 'File count quota',
      example: 1000,
    },
    objectStorageQuota: {
      type: 'string',
      description: 'Object storage quota (in bytes), including resource, canvas and static files',
      example: '104857600',
      deprecated: true,
    },
    resourceSize: {
      type: 'string',
      description: 'Resource storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    canvasSize: {
      type: 'string',
      description: 'Canvas storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    fileSize: {
      type: 'string',
      description: 'Static file storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    vectorStorageQuota: {
      type: 'string',
      description: 'Vector storage quota (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    vectorStorageUsed: {
      type: 'string',
      description: 'Vector storage size used (in bytes)',
      example: '1048576',
      deprecated: true,
    },
  },
} as const;

export const FileParsingMeterSchema = {
  type: 'object',
  required: ['pagesParsed', 'pagesLimit'],
  properties: {
    pagesParsed: {
      type: 'number',
      description: 'File pages parsed',
    },
    pagesLimit: {
      type: 'number',
      description: 'File pages limit',
    },
    fileUploadLimit: {
      type: 'number',
      description: 'File upload limit (in MB)',
    },
  },
} as const;

export const OperationModeSchema = {
  type: 'string',
  description: 'Operation mode',
  enum: ['mouse', 'touchpad'],
} as const;

export const ProviderConfigSchema = {
  type: 'object',
  description: 'Provider config',
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
  },
} as const;

export const ModelSceneSchema = {
  type: 'string',
  description: 'Model usage scene',
  enum: ['chat', 'queryAnalysis', 'titleGeneration'],
} as const;

export const DefaultModelConfigSchema = {
  type: 'object',
  description: 'Default model config',
  properties: {
    chat: {
      description: 'Default chat model to use',
      $ref: '#/components/schemas/ProviderItem',
    },
    queryAnalysis: {
      description: 'Query analysis and context processing model',
      $ref: '#/components/schemas/ProviderItem',
    },
    titleGeneration: {
      description: 'Title generation model for canvas and documents',
      $ref: '#/components/schemas/ProviderItem',
    },
  },
} as const;

export const UserPreferencesSchema = {
  type: 'object',
  description: 'User preferences',
  properties: {
    operationMode: {
      description: 'Operation mode',
      $ref: '#/components/schemas/OperationMode',
    },
    disableHoverCard: {
      type: 'boolean',
      description: 'Whether to disable hover tutorial',
      default: false,
    },
    webSearch: {
      description: 'Web search config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    urlParsing: {
      description: 'URL parsing config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    pdfParsing: {
      description: 'PDF parsing config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    defaultModel: {
      description: 'Default model config',
      $ref: '#/components/schemas/DefaultModelConfig',
    },
  },
} as const;

export const OnboardingStatusSchema = {
  type: 'string',
  description: 'Onboarding status',
  enum: ['not_started', 'skipped', 'completed'],
} as const;

export const OnboardingConfigSchema = {
  type: 'object',
  properties: {
    settings: {
      description: 'Settings onboarding status',
      $ref: '#/components/schemas/OnboardingStatus',
    },
    tour: {
      description: 'Tour onboarding status',
      $ref: '#/components/schemas/OnboardingStatus',
    },
  },
} as const;

export const UserSettingsSchema = {
  type: 'object',
  required: ['uid', 'avatar', 'name', 'email'],
  properties: {
    uid: {
      type: 'string',
      description: 'User ID',
      example: 'u-g30e1b80b5g1itbemc0g5jj3',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
      example: 'https://static.refly.ai/avatar/1.jpg',
    },
    name: {
      type: 'string',
      description: 'Username (can only contains letters, numbers, and underscores)',
      example: 'john_doe',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
      example: 'John Doe',
    },
    email: {
      type: 'string',
      description: 'User email',
      example: '6XJpZ@example.com',
    },
    emailVerified: {
      type: 'boolean',
      description: 'Whether email is verified',
      default: false,
    },
    uiLocale: {
      type: 'string',
      description: 'User UI locale',
      example: 'en',
    },
    outputLocale: {
      type: 'string',
      description: 'User output locale',
      example: 'en',
    },
    customerId: {
      type: 'string',
      description: 'Stripe customer ID',
    },
    subscription: {
      description: 'User subscription',
      $ref: '#/components/schemas/Subscription',
    },
    hasBetaAccess: {
      type: 'boolean',
      description: 'Whether the user has beta access',
      default: false,
    },
    preferences: {
      description: 'User preferences',
      $ref: '#/components/schemas/UserPreferences',
    },
    onboarding: {
      description: 'Onboarding config',
      $ref: '#/components/schemas/OnboardingConfig',
    },
  },
} as const;

export const AuthProviderSchema = {
  type: 'string',
  description: 'Auth provider',
  enum: ['email', 'google', 'github'],
} as const;

export const AuthConfigItemSchema = {
  type: 'object',
  required: ['provider'],
  properties: {
    provider: {
      description: 'Auth provider',
      $ref: '#/components/schemas/AuthProvider',
    },
  },
} as const;

export const AuthConfigResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Auth providers',
          items: {
            $ref: '#/components/schemas/AuthConfigItem',
          },
        },
      },
    },
  ],
} as const;

export const EmailSignupRequestSchema = {
  type: 'object',
  description: 'Email signup request',
  required: ['email', 'password'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const EmailSignupDataSchema = {
  type: 'object',
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
    skipVerification: {
      type: 'boolean',
      description: 'Whether email verification is skipped',
    },
  },
} as const;

export const EmailSignupResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/EmailSignupData',
        },
      },
    },
  ],
} as const;

export const VerificationPurposeSchema = {
  type: 'string',
  description: 'Verification purpose',
  enum: ['signup', 'resetPassword'],
} as const;

export const CreateVerificationRequestSchema = {
  type: 'object',
  description: 'Create verification session request',
  required: ['email', 'purpose'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    purpose: {
      type: 'string',
      description: 'Verification purpose',
      $ref: '#/components/schemas/VerificationPurpose',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const CreateVerificationDataSchema = {
  type: 'object',
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
  },
} as const;

export const CreateVerificationResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CreateVerificationData',
        },
      },
    },
  ],
} as const;

export const ResendVerificationRequestSchema = {
  type: 'object',
  description: 'Resend verification request',
  required: ['sessionId'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
  },
} as const;

export const CheckVerificationRequestSchema = {
  type: 'object',
  description: 'Check verification code request',
  required: ['sessionId', 'code'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
    code: {
      type: 'string',
      description: 'Verification code',
    },
  },
} as const;

export const EmailLoginRequestSchema = {
  type: 'object',
  description: 'Email login request',
  required: ['email', 'password'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const EmailLoginDataSchema = {
  type: 'object',
  properties: {
    accessToken: {
      type: 'string',
      description: 'Access token',
    },
  },
} as const;

export const EmailLoginResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/EmailLoginData',
        },
      },
    },
  ],
} as const;

export const GetUserSettingsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/UserSettings',
        },
      },
    },
  ],
} as const;

export const CollabTokenDataSchema = {
  type: 'object',
  required: ['token'],
  properties: {
    token: {
      type: 'string',
      description: 'Collab token',
    },
    expiresAt: {
      type: 'number',
      description: 'Token expiration time (in unix milliseconds)',
    },
  },
} as const;

export const GetCollabTokenResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CollabTokenData',
        },
      },
    },
  ],
} as const;

export const BaseResponseSchema = {
  type: 'object',
  required: ['success'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the operation was successful',
      example: true,
    },
    errCode: {
      type: 'string',
      description: 'Error code',
    },
    errMsg: {
      type: 'string',
      description: 'Error message',
      example: 'Operation failed',
    },
    traceId: {
      type: 'string',
      description: 'Trace ID',
    },
    stack: {
      type: 'string',
      description: 'Error stack (only returned in development environment)',
    },
  },
} as const;

export const ListCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas list',
          items: {
            $ref: '#/components/schemas/Canvas',
          },
        },
      },
    },
  ],
} as const;

export const GetCanvasDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Canvas',
        },
      },
    },
  ],
} as const;

export const RawCanvasDataSchema = {
  type: 'object',
  description: 'Raw canvas data',
  properties: {
    owner: {
      type: 'object',
      description: 'Canvas owner',
      $ref: '#/components/schemas/ShareUser',
    },
    title: {
      type: 'string',
      description: 'Canvas title',
    },
    minimapUrl: {
      type: 'string',
      description: 'Minimap URL',
    },
    nodes: {
      type: 'array',
      description: 'Canvas nodes',
      items: {
        type: 'object',
        $ref: '#/components/schemas/CanvasNode',
      },
    },
    edges: {
      type: 'array',
      description: 'Canvas edges',
      items: {
        type: 'object',
      },
    },
  },
} as const;

export const ExportCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Canvas data',
          $ref: '#/components/schemas/RawCanvasData',
        },
      },
    },
  ],
} as const;

export const DuplicateCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom canvas title',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    duplicateEntities: {
      type: 'boolean',
      description: 'Whether to duplicate entities within the canvas',
    },
  },
} as const;

export const DuplicateDocumentRequestSchema = {
  type: 'object',
  required: ['docId'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom document title for the duplicate',
    },
  },
} as const;

export const DuplicateResourceRequestSchema = {
  type: 'object',
  required: ['resourceId'],
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom resource title for the duplicate',
    },
  },
} as const;

export const UpsertCanvasRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My Canvas',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID (only used for update)',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    minimapStorageKey: {
      type: 'string',
      description: 'Minimap storage key',
    },
  },
} as const;

export const UpsertCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Canvas',
        },
      },
    },
  ],
} as const;

export const DeleteCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to delete',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    deleteAllFiles: {
      type: 'boolean',
      description: 'Whether to delete all files in the canvas',
      default: false,
    },
  },
} as const;

export const AutoNameCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    directUpdate: {
      type: 'boolean',
      description: 'Whether to directly update the canvas title',
      default: false,
    },
  },
} as const;

export const AutoNameCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Auto name canvas result',
          properties: {
            title: {
              type: 'string',
              description: 'New canvas title',
            },
          },
        },
      },
    },
  ],
} as const;

export const ListCanvasTemplateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas template list',
          items: {
            $ref: '#/components/schemas/CanvasTemplate',
          },
        },
      },
    },
  ],
} as const;

export const CreateCanvasTemplateRequestSchema = {
  type: 'object',
  required: ['canvasId', 'title', 'description', 'language'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    categoryId: {
      type: 'string',
      description: 'Canvas template category ID',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Cover storage key',
    },
  },
} as const;

export const UpdateCanvasTemplateRequestSchema = {
  type: 'object',
  required: ['templateId'],
  properties: {
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    categoryId: {
      type: 'string',
      description: 'Canvas template category ID',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
  },
} as const;

export const UpsertCanvasTemplateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Canvas template',
          $ref: '#/components/schemas/CanvasTemplate',
        },
      },
    },
  ],
} as const;

export const ListCanvasTemplateCategoryResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas template category list',
          items: {
            $ref: '#/components/schemas/CanvasTemplateCategory',
          },
        },
      },
    },
  ],
} as const;

export const UpsertResourceRequestSchema = {
  type: 'object',
  required: ['title', 'resourceType'],
  properties: {
    title: {
      type: 'string',
      description: 'Resource title',
      example: 'My Resource',
    },
    resourceType: {
      description: 'Resource type',
      $ref: '#/components/schemas/ResourceType',
    },
    resourceId: {
      type: 'string',
      description: 'Resource ID (only used for update)',
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    data: {
      description: 'Resource metadata',
      $ref: '#/components/schemas/ResourceMeta',
    },
    storageKey: {
      type: 'string',
      description: 'Storage key',
    },
    content: {
      type: 'string',
      description: 'Resource content (this will be ignored if storageKey was set)',
    },
  },
} as const;

export const UpsertResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Resource',
        },
      },
    },
  ],
} as const;

export const BatchCreateResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const ReindexResourceRequestSchema = {
  type: 'object',
  required: ['resourceIds'],
  properties: {
    resourceIds: {
      type: 'array',
      description: 'Resource ID list',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ReindexResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const DeleteResourceRequestSchema = {
  type: 'object',
  required: ['resourceId'],
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID to delete',
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ListResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const GetResourceDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Resource data',
          $ref: '#/components/schemas/Resource',
        },
      },
    },
  ],
} as const;

export const ListDocumentResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas list',
          items: {
            $ref: '#/components/schemas/Document',
          },
        },
      },
    },
  ],
} as const;

export const GetDocumentDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Document data',
          $ref: '#/components/schemas/Document',
        },
      },
    },
  ],
} as const;

export const UpsertDocumentRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My Canvas',
    },
    docId: {
      type: 'string',
      description: 'Document ID (only used for update)',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this document is read-only',
      default: false,
    },
    initialContent: {
      type: 'string',
      description: 'Document initial content',
    },
  },
} as const;

export const UpsertDocumentResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Document',
        },
      },
    },
  ],
} as const;

export const DeleteDocumentRequestSchema = {
  type: 'object',
  required: ['docId'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID to delete',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const GetActionResultResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ActionResult',
        },
      },
    },
  ],
} as const;

export const QueryReferencesRequestSchema = {
  type: 'object',
  properties: {
    sourceType: {
      description: 'Source entity type',
      $ref: '#/components/schemas/EntityType',
    },
    sourceId: {
      type: 'string',
      description: 'Source entity ID',
    },
    targetType: {
      description: 'Target entity type',
      $ref: '#/components/schemas/EntityType',
    },
    targetId: {
      type: 'string',
      description: 'Target entity ID',
    },
  },
} as const;

export const QueryReferencesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Reference list',
          items: {
            $ref: '#/components/schemas/Reference',
          },
        },
      },
    },
  ],
} as const;

export const AddReferencesRequestSchema = {
  type: 'object',
  required: ['references'],
  properties: {
    references: {
      type: 'array',
      description: 'Reference operation list',
      items: {
        $ref: '#/components/schemas/BaseReference',
      },
    },
  },
} as const;

export const AddReferencesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Reference list',
          items: {
            $ref: '#/components/schemas/Reference',
          },
        },
      },
    },
  ],
} as const;

export const DeleteReferencesRequestSchema = {
  type: 'object',
  required: ['referenceIds'],
  properties: {
    referenceIds: {
      type: 'array',
      description: 'Reference ID list',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ListProjectResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Project list',
          items: {
            $ref: '#/components/schemas/Project',
          },
        },
      },
    },
  ],
} as const;

export const GetProjectDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Project',
        },
      },
    },
  ],
} as const;

export const UpsertProjectRequestSchema = {
  type: 'object',
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID (only used for update)',
    },
    name: {
      type: 'string',
      description: 'Project name',
    },
    description: {
      type: 'string',
      description: 'Project description',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Project cover storage key',
    },
    customInstructions: {
      type: 'string',
      description: 'Custom instructions',
    },
  },
} as const;

export const UpsertProjectResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Project',
        },
      },
    },
  ],
} as const;

export const UpdateProjectItemsRequestSchema = {
  type: 'object',
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    operation: {
      type: 'string',
      description: 'Operation type',
      enum: ['add', 'remove'],
    },
    items: {
      type: 'array',
      description: 'Item list',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
  },
} as const;

export const DeleteProjectRequestSchema = {
  type: 'object',
  required: ['projectId'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID to delete',
      example: 'p-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const DeleteProjectItemsRequestSchema = {
  type: 'object',
  required: ['projectId', 'items'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    items: {
      type: 'array',
      description: 'Item list',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
  },
} as const;

export const SkillEventTypeSchema = {
  type: 'string',
  description: 'Skill event type',
  enum: [
    'start',
    'end',
    'stream',
    'log',
    'artifact',
    'structured_data',
    'token_usage',
    'create_node',
    'error',
  ],
} as const;

export const SkillEventSchema = {
  type: 'object',
  required: ['event'],
  properties: {
    event: {
      description: 'Event type',
      $ref: '#/components/schemas/SkillEventType',
    },
    skillMeta: {
      description: 'Skill metadata',
      $ref: '#/components/schemas/SkillMeta',
    },
    step: {
      description: 'Action step metadata',
      $ref: '#/components/schemas/ActionStepMeta',
    },
    resultId: {
      type: 'string',
      description: 'Result ID',
    },
    version: {
      type: 'number',
      description: 'Result version',
    },
    content: {
      type: 'string',
      description: 'Event content. Only present when `event` is `stream`',
    },
    reasoningContent: {
      type: 'string',
      description: 'Reasoning content. Only present when `event` is `stream`',
    },
    tokenUsage: {
      description: 'Token usage data. Only present when `event` is `token_usage`.',
      $ref: '#/components/schemas/TokenUsageItem',
    },
    log: {
      description: 'Log data. Only present when `event` is `log`.',
      $ref: '#/components/schemas/ActionLog',
    },
    structuredData: {
      type: 'object',
      description: 'Structured data. Only present when `event` is `structured_data`.',
    },
    artifact: {
      description: 'Artifact data. Only present when `event` is `artifact`.',
      $ref: '#/components/schemas/Artifact',
    },
    node: {
      description: 'Canvas node data. Only present when `event` is `create_node`.',
      $ref: '#/components/schemas/CanvasNode',
    },
    error: {
      description: 'Error data. Only present when `event` is `error`.',
      $ref: '#/components/schemas/BaseResponse',
      deprecated: true,
    },
    originError: {
      type: 'string',
      description: 'Original error message. Only present when `event` is `error`.',
    },
  },
} as const;

export const ShareRecordSchema = {
  type: 'object',
  required: ['shareId', 'entityType', 'entityId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
    title: {
      type: 'string',
      description: 'Share title',
    },
    entityType: {
      $ref: '#/components/schemas/EntityType',
      description: 'Entity type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    allowDuplication: {
      type: 'boolean',
      description: 'Whether to allow duplication of the shared entity',
    },
    parentShareId: {
      type: 'string',
      description: 'Parent share ID',
    },
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
    },
    createdAt: {
      type: 'string',
      description: 'Create timestamp',
    },
    updatedAt: {
      type: 'string',
      description: 'Update timestamp',
    },
  },
} as const;

export const UpsertCodeArtifactRequestSchema = {
  type: 'object',
  properties: {
    artifactId: {
      type: 'string',
      description: 'Code artifact ID (not needed for creation)',
    },
    title: {
      type: 'string',
      description: 'Code artifact title',
    },
    type: {
      type: 'string',
      description: 'Code artifact type',
    },
    content: {
      type: 'string',
      description: 'Code artifact content',
    },
    language: {
      type: 'string',
      description: 'Code artifact language',
    },
    previewStorageKey: {
      type: 'string',
      description: 'Code artifact preview storage key',
    },
    createIfNotExists: {
      type: 'boolean',
      description: 'Whether to create the code artifact if it does not exist',
      default: false,
    },
  },
} as const;

export const UpsertCodeArtifactResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CodeArtifact',
        },
      },
    },
  ],
} as const;

export const GetCodeArtifactDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CodeArtifact',
        },
      },
    },
  ],
} as const;

export const CreateShareRequestSchema = {
  type: 'object',
  required: ['entityType', 'entityId'],
  properties: {
    entityType: {
      $ref: '#/components/schemas/EntityType',
      description: 'Entity type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    title: {
      type: 'string',
      description: 'Share title',
    },
    allowDuplication: {
      type: 'boolean',
      description: 'Whether to allow duplication of the shared entity',
      default: false,
    },
    parentShareId: {
      type: 'string',
      description: 'Parent share ID',
    },
    shareData: {
      type: 'string',
      description: 'Raw share data (JSON string)',
    },
    shareDataStorageKey: {
      type: 'string',
      description: 'Share data storage key',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Cover storage key',
    },
  },
} as const;

export const CreateShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ShareRecord',
          description: 'Share created',
        },
      },
    },
  ],
} as const;

export const ListShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Share record list',
          items: {
            $ref: '#/components/schemas/ShareRecord',
          },
        },
      },
    },
  ],
} as const;

export const DeleteShareRequestSchema = {
  type: 'object',
  required: ['shareId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
  },
} as const;

export const DuplicateShareRequestSchema = {
  type: 'object',
  required: ['shareId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to duplicate the share to',
    },
  },
} as const;

export const DuplicateShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Duplicated entity',
          $ref: '#/components/schemas/Entity',
        },
      },
    },
  ],
} as const;

export const ListLabelClassesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label class list',
          items: {
            $ref: '#/components/schemas/LabelClass',
          },
        },
      },
    },
  ],
} as const;

export const CreateLabelClassRequestSchema = {
  type: 'object',
  required: ['name', 'displayName', 'prompt'],
  properties: {
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'my_class',
    },
    displayName: {
      type: 'string',
      description: 'Label display name',
      example: 'My Class',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
  },
} as const;

export const UpdateLabelClassRequestSchema = {
  type: 'object',
  required: ['labelClassId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
    },
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'My Class',
    },
    displayName: {
      type: 'string',
      description: 'Label display name',
      example: 'My Class',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
  },
} as const;

export const UpsertLabelClassResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Label class upserted',
          $ref: '#/components/schemas/LabelClass',
        },
      },
    },
  ],
} as const;

export const DeleteLabelClassRequestSchema = {
  type: 'object',
  required: ['labelClassId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID to delete',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ListLabelInstancesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label list',
          items: {
            $ref: '#/components/schemas/LabelInstance',
          },
        },
      },
    },
  ],
} as const;

export const CreateLabelInstanceRequestSchema = {
  type: 'object',
  required: ['labelClassId', 'valueList', 'entityType', 'entityId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    valueList: {
      type: 'array',
      description: 'Label value list',
      items: {
        type: 'string',
        example: 'label-1',
      },
    },
    entityType: {
      description: 'Label entity type',
      $ref: '#/components/schemas/EntityType',
    },
    entityId: {
      description: 'Label entity ID',
      type: 'string',
    },
  },
} as const;

export const UpdateLabelInstanceRequestSchema = {
  type: 'object',
  properties: {
    labelId: {
      type: 'string',
      description: 'Label ID to update',
    },
    value: {
      type: 'string',
      description: 'Updated label value',
    },
  },
} as const;

export const UpsertLabelInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label instance upserted',
          items: {
            $ref: '#/components/schemas/LabelInstance',
          },
        },
      },
    },
  ],
} as const;

export const DeleteLabelInstanceRequestSchema = {
  type: 'object',
  required: ['labelId'],
  properties: {
    labelId: {
      type: 'string',
      description: 'Label ID to delete',
      example: 'lb-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ActionSchema = {
  type: 'object',
  required: ['actionType', 'actionName'],
  properties: {
    actionType: {
      type: 'string',
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    actionName: {
      type: 'string',
      description: 'Action name',
    },
    icon: {
      description: 'Action icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const ListActionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Action list',
          items: {
            $ref: '#/components/schemas/Action',
          },
        },
      },
    },
  ],
} as const;

export const ListSkillResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill list',
          items: {
            $ref: '#/components/schemas/Skill',
          },
        },
      },
    },
  ],
} as const;

export const ListSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill list',
          items: {
            $ref: '#/components/schemas/SkillInstance',
          },
        },
      },
    },
  ],
} as const;

export const SkillInstanceCreateParamSchema = {
  type: 'object',
  required: ['displayName'],
  properties: {
    tplName: {
      type: 'string',
      description: 'Skill template name',
      example: 'online-search',
    },
    displayName: {
      type: 'string',
      description: 'Skill display name',
      example: 'My Custom Skill',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill instance icon',
      $ref: '#/components/schemas/Icon',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const CreateSkillInstanceRequestSchema = {
  type: 'object',
  required: ['instanceList'],
  properties: {
    instanceList: {
      type: 'array',
      description: 'Skill instances to upsert',
      items: {
        $ref: '#/components/schemas/SkillInstanceCreateParam',
      },
    },
  },
} as const;

export const CreateSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill instance list',
          items: {
            $ref: '#/components/schemas/SkillInstance',
          },
        },
      },
    },
  ],
} as const;

export const UpdateSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 's-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Skill display name',
      example: 'My Custom Skill',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill instance icon',
      $ref: '#/components/schemas/Icon',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const UpdateSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Skill instance list',
          $ref: '#/components/schemas/SkillInstance',
        },
      },
    },
  ],
} as const;

export const PinSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to pin',
    },
  },
} as const;

export const UnpinSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to unpin',
    },
  },
} as const;

export const DeleteSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to delete',
    },
  },
} as const;

export const SkillInputSchema = {
  type: 'object',
  description: 'Skill input',
  properties: {
    query: {
      type: 'string',
      description: 'User query',
    },
    images: {
      type: 'array',
      description: 'Image list (storage keys)',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const SkillContextResourceItemSchema = {
  type: 'object',
  description: 'Skill context resource item',
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID (if empty, this will be considered as external resource)',
    },
    resource: {
      description: 'Resource',
      $ref: '#/components/schemas/Resource',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this resource is current',
    },
    metadata: {
      type: 'object',
      description: 'Resource context metadata',
    },
  },
} as const;

export const SkillContextDocumentItemSchema = {
  type: 'object',
  description: 'Skill context document item',
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID',
    },
    document: {
      description: 'Document',
      $ref: '#/components/schemas/Document',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this document is current',
    },
    metadata: {
      type: 'object',
      description: 'Canvas context metadata',
    },
  },
} as const;

export const SkillContextCodeArtifactItemSchema = {
  type: 'object',
  description: 'Skill context code artifact item',
  properties: {
    artifactId: {
      type: 'string',
      description: 'Artifact ID',
    },
    codeArtifact: {
      description: 'Code artifact',
      $ref: '#/components/schemas/CodeArtifact',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this code artifact is current',
    },
    metadata: {
      type: 'object',
      description: 'Code artifact context metadata',
    },
  },
} as const;

export const SkillContextContentItemSchema = {
  type: 'object',
  description: 'Skill context content item',
  required: ['content'],
  properties: {
    content: {
      type: 'string',
      description: 'Content',
    },
    metadata: {
      type: 'object',
      description: 'Content context metadata',
    },
  },
} as const;

export const SkillContextUrlItemSchema = {
  type: 'object',
  description: 'Skill context url item',
  required: ['url'],
  properties: {
    url: {
      type: 'string',
      description: 'URL',
    },
    metadata: {
      type: 'object',
      description: 'URL context metadata',
    },
  },
} as const;

export const SkillContextSchema = {
  type: 'object',
  description: 'Skill invocation context',
  properties: {
    resources: {
      type: 'array',
      description: 'Context resources',
      items: {
        $ref: '#/components/schemas/SkillContextResourceItem',
      },
    },
    documents: {
      type: 'array',
      description: 'Context documents',
      items: {
        $ref: '#/components/schemas/SkillContextDocumentItem',
      },
    },
    codeArtifacts: {
      type: 'array',
      description: 'Context code artifacts',
      items: {
        $ref: '#/components/schemas/SkillContextCodeArtifactItem',
      },
    },
    contentList: {
      type: 'array',
      description: 'Context content list',
      items: {
        $ref: '#/components/schemas/SkillContextContentItem',
      },
    },
    urls: {
      type: 'array',
      description: 'List of URLs',
      items: {
        $ref: '#/components/schemas/SkillContextUrlItem',
      },
    },
  },
} as const;

export const SkillContextKeySchema = {
  type: 'string',
  enum: ['resources', 'documents', 'contentList', 'urls'],
} as const;

export const SelectionKeySchema = {
  type: 'string',
  enum: [
    'documentSelection',
    'resourceSelection',
    'skillResponseSelection',
    'extensionWeblinkSelection',
    'documentCursorSelection',
    'documentBeforeCursorSelection',
    'documentAfterCursorSelection',
  ],
} as const;

export const SkillContextRuleSchema = {
  type: 'object',
  required: ['key'],
  properties: {
    key: {
      type: 'string',
      description: 'Context key',
      $ref: '#/components/schemas/SkillContextKey',
    },
    limit: {
      type: 'number',
      description: 'Maximum number of items',
      default: 50,
    },
    required: {
      type: 'boolean',
      description: 'Whether this context is required',
      default: false,
    },
    preferredSelectionKeys: {
      type: 'array',
      description: 'Preferred selection keys (only applicable when key is `contentList`)',
      items: {
        $ref: '#/components/schemas/SelectionKey',
      },
    },
  },
} as const;

export const ContextRuleGroupRelationSchema = {
  type: 'string',
  enum: ['regular', 'mutuallyExclusive'],
} as const;

export const SkillContextRuleGroupSchema = {
  type: 'object',
  required: ['rules'],
  properties: {
    rules: {
      type: 'array',
      description: 'Skill context rules',
      items: {
        $ref: '#/components/schemas/SkillContextRule',
      },
    },
    relation: {
      type: 'string',
      description: 'Rule group relation',
      default: 'regular',
      $ref: '#/components/schemas/ContextRuleGroupRelation',
    },
    preferredContextKeys: {
      type: 'array',
      description: 'Preferred context keys',
      items: {
        $ref: '#/components/schemas/SkillContextKey',
      },
    },
  },
} as const;

export const SkillInvocationConfigSchema = {
  type: 'object',
  properties: {
    context: {
      description: 'Skill context rule group',
      $ref: '#/components/schemas/SkillContextRuleGroup',
    },
  },
} as const;

export const ActionTypeSchema = {
  type: 'string',
  enum: ['skill', 'tool'],
} as const;

export const ActionContextTypeSchema = {
  type: 'string',
  enum: ['resource', 'document'],
} as const;

export const ActionContextEntitySchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Entity title',
    },
    content: {
      type: 'string',
      description: 'Entity content',
    },
  },
} as const;

export const ActionContextItemSchema = {
  type: 'object',
  properties: {
    type: {
      description: 'Context item type',
      $ref: '#/components/schemas/ActionContextType',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityData: {
      description: 'Entity data (will be auto populated if not provided)',
      $ref: '#/components/schemas/ActionContextEntity',
    },
    metadata: {
      type: 'object',
      description: 'Context metadata',
    },
  },
} as const;

export const InvokeSkillRequestSchema = {
  type: 'object',
  properties: {
    documentContent: {
      type: 'string',
    },
    skillId: {
      type: 'string',
    },
    skillName: {
      type: 'string',
    },
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    context: {
      description: 'Skill invocation context',
      $ref: '#/components/schemas/SkillContext',
    },
    resultHistory: {
      type: 'array',
      description: 'Skill result history',
      items: {
        $ref: '#/components/schemas/ActionResult',
      },
    },
    runtimeConfig: {
      description: 'Skill runtime config',
      $ref: '#/components/schemas/SkillRuntimeConfig',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
    target: {
      description: 'Skill invocation target',
      $ref: '#/components/schemas/Entity',
    },
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    resultId: {
      type: 'string',
      description: `Result ID associated with this invocation.
1) If not provided, a new resultId will be generated.
2) If there is no existing result with this resultId, it will be created and run.
3) If there is an existing result with this resultId, it will be rerun.
`,
    },
    locale: {
      type: 'string',
      description: 'Selected output locale',
    },
    modelName: {
      type: 'string',
      description: 'Selected model',
      deprecated: true,
    },
    modelItemId: {
      type: 'string',
      description: 'Selected model item ID',
    },
    triggerId: {
      type: 'string',
      description: 'Trigger ID',
    },
    selectedMcpServers: {
      type: 'array',
      description: 'Selected MCP servers',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const InvokeSkillResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        resultId: {
          type: 'string',
          description: 'Skill result ID',
        },
      },
    },
  ],
} as const;

export const ListSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill trigger list',
          items: {
            $ref: '#/components/schemas/SkillTrigger',
          },
        },
      },
    },
  ],
} as const;

export const SkillTriggerCreateParamSchema = {
  type: 'object',
  required: ['skillId', 'displayName', 'triggerType'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 'sk-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Trigger display name',
      example: 'My trigger',
    },
    triggerType: {
      description: 'Trigger type',
      $ref: '#/components/schemas/SkillTriggerType',
    },
    simpleEventName: {
      description: 'Simple event name (only required when trigger type is `simpleEvent`)',
      $ref: '#/components/schemas/SimpleEventName',
    },
    timerConfig: {
      description: 'Timer config (only required when trigger type is `timer`)',
      $ref: '#/components/schemas/TimerTriggerConfig',
    },
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    context: {
      description: 'Skill invocation context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether this trigger is enabled',
    },
  },
} as const;

export const CreateSkillTriggerRequestSchema = {
  type: 'object',
  required: ['triggerList'],
  properties: {
    triggerList: {
      type: 'array',
      description: 'Skill triggers to upsert',
      items: {
        $ref: '#/components/schemas/SkillTriggerCreateParam',
      },
    },
  },
} as const;

export const CreateSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill trigger list',
          items: {
            $ref: '#/components/schemas/SkillTrigger',
          },
        },
      },
    },
  ],
} as const;

export const UpdateSkillTriggerRequestSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/SkillTriggerCreateParam',
    },
    {
      type: 'object',
      required: ['triggerId'],
      properties: {
        triggerId: {
          type: 'string',
          description: 'Trigger ID',
          example: 'tr-g30e1b80b5g1itbemc0g5jj3',
        },
      },
    },
  ],
} as const;

export const UpdateSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Updated skill trigger',
          $ref: '#/components/schemas/SkillTrigger',
        },
      },
    },
  ],
} as const;

export const DeleteSkillTriggerRequestSchema = {
  type: 'object',
  required: ['triggerId'],
  properties: {
    triggerId: {
      type: 'string',
      description: 'Trigger ID to delete',
    },
  },
} as const;

export const UpdateUserSettingsRequestSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'User name',
      example: 'john_name',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
      example: 'John Doe',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
    },
    avatarStorageKey: {
      type: 'string',
      description: 'User avatar storage key',
    },
    uiLocale: {
      type: 'string',
      description: 'UI locale',
      example: 'en',
    },
    outputLocale: {
      type: 'string',
      description: 'Output locale',
      example: 'en',
    },
    preferences: {
      description: 'User preferences',
      $ref: '#/components/schemas/UserPreferences',
    },
    onboarding: {
      description: 'Onboarding config',
      $ref: '#/components/schemas/OnboardingConfig',
    },
  },
} as const;

export const CheckSettingsFieldResultSchema = {
  type: 'object',
  required: ['field', 'value', 'available'],
  properties: {
    field: {
      type: 'string',
      description: 'Settings field',
    },
    value: {
      type: 'string',
      description: 'Settings field value',
    },
    available: {
      type: 'boolean',
      description: 'Whether the field value is available',
    },
  },
} as const;

export const CheckSettingsFieldResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Settings field check result',
          $ref: '#/components/schemas/CheckSettingsFieldResult',
        },
      },
    },
  ],
} as const;

export const CreateCheckoutSessionRequestSchema = {
  type: 'object',
  required: ['planType'],
  properties: {
    planType: {
      description: 'Subscription plan type',
      $ref: '#/components/schemas/SubscriptionPlanType',
    },
    interval: {
      description: 'Subscription billing interval',
      $ref: '#/components/schemas/SubscriptionInterval',
    },
  },
} as const;

export const CreateCheckoutSessionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Checkout session',
          properties: {
            url: {
              type: 'string',
              description: 'Checkout session URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const CreatePortalSessionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Portal session',
          properties: {
            url: {
              type: 'string',
              description: 'Portal session URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const SubscriptionPlanSchema = {
  type: 'object',
  properties: {
    planType: {
      type: 'string',
      description: 'Subscription plan type',
    },
    t1TokenQuota: {
      type: 'number',
      description: 'Token quota per month (T1)',
    },
    t2TokenQuota: {
      type: 'number',
      description: 'Token quota per month (T2)',
    },
    objectStorageQuota: {
      type: 'string',
      description: 'Object storage quota (in bytes)',
    },
    vectorStorageQuota: {
      type: 'string',
      description: 'Vector storage quota (in bytes)',
    },
  },
} as const;

export const GetSubscriptionPlansResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Subscription plans',
          items: {
            $ref: '#/components/schemas/SubscriptionPlan',
          },
        },
      },
    },
  ],
} as const;

export const SubscriptionUsageDataSchema = {
  type: 'object',
  properties: {
    token: {
      description: 'Token usage meter',
      $ref: '#/components/schemas/TokenUsageMeter',
    },
    storage: {
      description: 'Storage usage meter',
      $ref: '#/components/schemas/StorageUsageMeter',
    },
    fileParsing: {
      description: 'File parsing meter',
      $ref: '#/components/schemas/FileParsingMeter',
    },
  },
} as const;

export const GetSubscriptionUsageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Subscription usage',
          $ref: '#/components/schemas/SubscriptionUsageData',
        },
      },
    },
  ],
} as const;

export const WebSearchRequestSchema = {
  type: 'object',
  properties: {
    q: {
      type: 'string',
      description: 'Search query',
    },
    hl: {
      type: 'string',
      description: 'Language/locale code',
    },
    gl: {
      type: 'string',
      description: 'Country/region code',
    },
    location: {
      type: 'string',
      description: 'Location string',
    },
    limit: {
      type: 'number',
      description: 'Web search result limit',
      default: 10,
    },
  },
} as const;

export const BatchWebSearchRequestSchema = {
  type: 'object',
  properties: {
    limit: {
      type: 'number',
      description: 'Web search result limit',
      default: 10,
    },
    queries: {
      type: 'array',
      description: 'Web search queries',
      items: {
        $ref: '#/components/schemas/WebSearchRequest',
      },
    },
  },
} as const;

export const MultiLingualWebSearchRequestSchema = {
  type: 'object',
  required: ['query', 'searchLocaleList'],
  properties: {
    query: {
      type: 'string',
      description: 'Search query',
    },
    searchLocaleList: {
      type: 'array',
      description: 'List of search locales',
      items: {
        type: 'string',
      },
    },
    displayLocale: {
      type: 'string',
      description: 'Display locale',
      default: 'auto',
    },
    searchLimit: {
      type: 'number',
      description: 'Web search result limit per locale',
    },
    enableRerank: {
      type: 'boolean',
      description: 'Whether to enable reranking of search results',
    },
    rerankLimit: {
      type: 'number',
      description: 'Limit for reranked results',
    },
    rerankRelevanceThreshold: {
      type: 'number',
      description: 'Relevance threshold for reranking',
    },
  },
} as const;

export const MultiLingualWebSearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Multilingual web search results',
          required: ['sources', 'searchSteps'],
          properties: {
            sources: {
              type: 'array',
              description: 'Search result sources',
              items: {
                $ref: '#/components/schemas/Source',
              },
            },
            searchSteps: {
              type: 'array',
              description: 'Search steps',
              items: {
                $ref: '#/components/schemas/SearchStep',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const WebSearchResultSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'Web search result name',
    },
    url: {
      type: 'string',
      description: 'Web search result url',
    },
    snippet: {
      type: 'string',
      description: 'Web search result snippet',
    },
    locale: {
      type: 'string',
      description: 'Web search result locale',
    },
  },
} as const;

export const WebSearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Web search results',
          items: {
            $ref: '#/components/schemas/WebSearchResult',
          },
        },
      },
    },
  ],
} as const;

export const RerankResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Reranked results',
          items: {
            $ref: '#/components/schemas/SearchResult',
          },
        },
      },
    },
  ],
} as const;

export const SearchOptionsSchema = {
  type: 'object',
  description: 'Search options for internal use',
  properties: {
    enableReranker: {
      type: 'boolean',
      description: 'Whether to enable reranker',
      default: true,
    },
  },
} as const;

export const SearchDomainSchema = {
  type: 'string',
  enum: ['resource', 'document', 'canvas'],
} as const;

export const SearchModeSchema = {
  type: 'string',
  enum: ['keyword', 'vector', 'hybrid'],
} as const;

export const SearchRequestSchema = {
  type: 'object',
  required: ['query'],
  properties: {
    query: {
      type: 'string',
      description: 'Search query (if empty, return last updated data)',
    },
    domains: {
      type: 'array',
      description: 'Search domains (if not specified, return all domains)',
      items: {
        $ref: '#/components/schemas/SearchDomain',
      },
    },
    entities: {
      type: 'array',
      description: 'Search entities',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
    mode: {
      type: 'string',
      description: 'Search mode',
      $ref: '#/components/schemas/SearchMode',
      default: 'keyword',
    },
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    limit: {
      type: 'number',
      description: 'Search result limit for each domain',
      default: 5,
    },
  },
} as const;

export const SearchResultSnippetSchema = {
  type: 'object',
  properties: {
    text: {
      type: 'string',
      description: 'Search result content text',
    },
    highlightedText: {
      type: 'string',
      description: 'Search result highlighted content text with em html tags',
    },
  },
} as const;

export const SearchResultSchema = {
  type: 'object',
  required: ['id', 'domain', 'title'],
  properties: {
    id: {
      type: 'string',
      description: 'Search result ID to navigate to',
    },
    domain: {
      description: 'Search result domain',
      $ref: '#/components/schemas/SearchDomain',
    },
    title: {
      type: 'string',
      description: 'Search result title',
    },
    highlightedTitle: {
      type: 'string',
      description: 'Search result highlighted title with em html tags',
    },
    contentPreview: {
      type: 'string',
      description: 'Search result content preview',
    },
    snippets: {
      type: 'array',
      description: 'Search result content list with highlight marks',
      items: {
        $ref: '#/components/schemas/SearchResultSnippet',
      },
    },
    relevanceScore: {
      type: 'number',
      description: 'Search result relevance score',
    },
    metadata: {
      type: 'object',
      description: 'Search result metadata',
      additionalProperties: true,
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Data creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Data update time',
    },
  },
} as const;

export const SearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Search result',
          items: {
            $ref: '#/components/schemas/SearchResult',
          },
        },
      },
    },
  ],
} as const;

export const ScrapeWeblinkRequestSchema = {
  type: 'object',
  required: ['url'],
  properties: {
    url: {
      type: 'string',
      description: 'Weblink URL',
    },
  },
} as const;

export const ScrapeWeblinkResultSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Weblink title',
    },
    description: {
      type: 'string',
      description: 'Weblink description',
    },
    image: {
      type: 'string',
      description: 'Weblink image',
    },
  },
} as const;

export const ScrapeWeblinkResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Weblink scrape result',
          $ref: '#/components/schemas/ScrapeWeblinkResult',
        },
      },
    },
  ],
} as const;

export const FileVisibilitySchema = {
  type: 'string',
  enum: ['public', 'private'],
} as const;

export const UploadRequestSchema = {
  type: 'object',
  required: ['file'],
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      description: 'File to upload',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
    visibility: {
      description: 'File visibility (default is private)',
      $ref: '#/components/schemas/FileVisibility',
    },
    storageKey: {
      type: 'string',
      description: 'Storage key (if provided, the file will be replaced if it already exists)',
    },
  },
} as const;

export const UploadResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'File upload result',
          required: ['url', 'storageKey'],
          properties: {
            url: {
              type: 'string',
              description: 'File URL',
            },
            storageKey: {
              type: 'string',
              description: 'Storage key',
            },
          },
        },
      },
    },
  ],
} as const;

export const ConvertRequestSchema = {
  type: 'object',
  required: ['file'],
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      description: 'The file to convert',
    },
    from: {
      type: 'string',
      description: 'Source format (e.g., html)',
      default: 'html',
    },
    to: {
      type: 'string',
      description: 'Target format (e.g., markdown)',
      default: 'markdown',
    },
  },
} as const;

export const ConvertResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description: 'Converted markdown content',
            },
          },
        },
      },
    },
  ],
} as const;

export const ModelCapabilitiesSchema = {
  type: 'object',
  properties: {
    functionCall: {
      type: 'boolean',
      description: 'Whether this model supports function calling',
    },
    vision: {
      type: 'boolean',
      description: 'Whether this model can take images as input',
    },
    reasoning: {
      type: 'boolean',
      description: 'Whether this model includes reasoning content',
    },
    contextCaching: {
      type: 'boolean',
      description: 'Whether this model supports context caching',
    },
  },
} as const;

export const ModelInfoSchema = {
  type: 'object',
  required: ['name', 'label', 'provider', 'contextLimit', 'maxOutput'],
  properties: {
    name: {
      type: 'string',
      description: 'Model name',
    },
    label: {
      type: 'string',
      description: 'Model label',
    },
    provider: {
      type: 'string',
      description: 'Model provider',
    },
    providerItemId: {
      type: 'string',
      description: 'Model provider item ID',
    },
    tier: {
      type: 'string',
      description: 'Model tier',
      $ref: '#/components/schemas/ModelTier',
    },
    contextLimit: {
      type: 'number',
      description: 'Model context limit (in tokens)',
    },
    maxOutput: {
      type: 'number',
      description: 'Model max output length (in tokens)',
    },
    capabilities: {
      description: 'Model capabilities',
      $ref: '#/components/schemas/ModelCapabilities',
    },
    isDefault: {
      type: 'boolean',
      description: 'Whether this model is the default model',
    },
    group: {
      type: 'string',
      description: 'Model group',
    },
  },
} as const;

export const ListModelsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Model list',
          items: {
            $ref: '#/components/schemas/ModelInfo',
          },
        },
      },
    },
  ],
} as const;

export const ProviderCategorySchema = {
  type: 'string',
  enum: ['llm', 'embedding', 'reranker', 'webSearch', 'urlParsing', 'pdfParsing'],
} as const;

export const ProviderSchema = {
  type: 'object',
  description: 'General provider info',
  required: ['providerId', 'providerKey', 'categories', 'name', 'enabled'],
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
    name: {
      type: 'string',
      description: 'Provider name',
    },
    categories: {
      type: 'array',
      description: 'Provider categories',
      items: {
        $ref: '#/components/schemas/ProviderCategory',
      },
    },
    baseUrl: {
      type: 'string',
      description: 'Provider base URL',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider is enabled',
    },
    isGlobal: {
      type: 'boolean',
      description: 'Whether the provider is global',
    },
    apiKey: {
      type: 'string',
      description: 'Provider API key (this will never be exposed to the frontend)',
    },
  },
} as const;

export const LLMModelConfigSchema = {
  type: 'object',
  description: 'Provider config for LLMs',
  required: ['modelId', 'modelName'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Model ID',
    },
    modelName: {
      type: 'string',
      description: 'Model name',
    },
    contextLimit: {
      type: 'number',
      description: 'Model context limit (in tokens)',
    },
    maxOutput: {
      type: 'number',
      description: 'Model max output length (in tokens)',
    },
    capabilities: {
      description: 'Model capabilities',
      $ref: '#/components/schemas/ModelCapabilities',
    },
  },
} as const;

export const EmbeddingModelConfigSchema = {
  type: 'object',
  description: 'Provider config for embeddings',
  required: ['modelId', 'dimensions'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Embedding model ID',
    },
    modelName: {
      type: 'string',
      description: 'Embedding model name',
    },
    dimensions: {
      type: 'number',
      description: 'Embedding model dimension',
    },
    batchSize: {
      type: 'number',
      description: 'Embedding model batch size',
    },
  },
} as const;

export const RerankerModelConfigSchema = {
  type: 'object',
  description: 'Provider config for rerankers',
  required: ['modelId'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Reranking model ID',
    },
    modelName: {
      type: 'string',
      description: 'Reranking model name',
    },
    topN: {
      type: 'number',
      description: 'Number of top results to return',
    },
    relevanceThreshold: {
      type: 'number',
      description: 'Minimum relevance score threshold (0.0-1.0)',
    },
  },
} as const;

export const ProviderItemConfigSchema = {
  oneOf: [
    {
      $ref: '#/components/schemas/LLMModelConfig',
    },
    {
      $ref: '#/components/schemas/EmbeddingModelConfig',
    },
    {
      $ref: '#/components/schemas/RerankerModelConfig',
    },
  ],
} as const;

export const ProviderItemOptionSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    tier: {
      type: 'string',
      description: 'Provider item tier',
      $ref: '#/components/schemas/ModelTier',
    },
    config: {
      type: 'object',
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
  },
} as const;

export const ProviderItemSchema = {
  type: 'object',
  required: ['itemId', 'name', 'providerId', 'category', 'enabled'],
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID',
    },
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider item is enabled',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    tier: {
      description: 'Provider item tier',
      $ref: '#/components/schemas/ModelTier',
    },
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    provider: {
      type: 'object',
      description: 'Provider detail info',
      $ref: '#/components/schemas/Provider',
    },
    config: {
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
    order: {
      type: 'number',
      description: 'Provider item order',
    },
    group: {
      type: 'string',
      description: 'Provider item group',
    },
  },
} as const;

export const ListProvidersResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/Provider',
          },
        },
      },
    },
  ],
} as const;

export const UpsertProviderRequestSchema = {
  type: 'object',
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID (only for update)',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
    name: {
      type: 'string',
      description: 'Provider name',
    },
    categories: {
      type: 'array',
      description: 'Provider categories',
      items: {
        $ref: '#/components/schemas/ProviderCategory',
      },
    },
    apiKey: {
      type: 'string',
      description: 'Provider API key',
    },
    baseUrl: {
      type: 'string',
      description: 'Provider base URL',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider is enabled',
    },
  },
} as const;

export const UpsertProviderResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Provider',
        },
      },
    },
  ],
} as const;

export const DeleteProviderRequestSchema = {
  type: 'object',
  required: ['providerId'],
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
  },
} as const;

export const ListProviderItemOptionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ProviderItemOption',
          },
        },
      },
    },
  ],
} as const;

export const ListProviderItemsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ProviderItem',
          },
        },
      },
    },
  ],
} as const;

export const UpsertProviderItemRequestSchema = {
  type: 'object',
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID (only for update)',
    },
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider item is enabled',
    },
    config: {
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
    order: {
      type: 'number',
      description: 'Provider item order',
    },
    group: {
      type: 'string',
      description: 'Provider item group',
    },
  },
} as const;

export const UpsertProviderItemResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ProviderItem',
        },
      },
    },
  ],
} as const;

export const BatchUpsertProviderItemsRequestSchema = {
  type: 'object',
  required: ['items'],
  properties: {
    items: {
      type: 'array',
      description: 'Provider items to upsert',
      items: {
        $ref: '#/components/schemas/UpsertProviderItemRequest',
      },
    },
  },
} as const;

export const BatchUpsertProviderItemsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Upserted provider items',
          items: {
            $ref: '#/components/schemas/ProviderItem',
          },
        },
      },
    },
  ],
} as const;

export const DeleteProviderItemRequestSchema = {
  type: 'object',
  required: ['itemId'],
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID',
    },
  },
} as const;

export const DocumentInterfaceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      description:
        'An optional identifier for the document. Ideally this should be unique across the document collection and formatted as a UUID.',
    },
    pageContent: {
      type: 'string',
      description: 'The main content of the document.',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Metadata associated with the document.',
    },
  },
} as const;

export const InMemorySearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/DocumentInterface',
          },
        },
      },
    },
  ],
} as const;

export const CanvasNodeTypeSchema = {
  type: 'string',
  enum: [
    'document',
    'codeArtifact',
    'website',
    'resource',
    'skill',
    'tool',
    'skillResponse',
    'toolResponse',
    'memo',
    'group',
    'image',
  ],
} as const;

export const CanvasNodeDataSchema = {
  type: 'object',
  required: ['title', 'entityId'],
  properties: {
    title: {
      type: 'string',
      description: 'Node title',
    },
    entityId: {
      type: 'string',
      description: 'Node entity ID',
    },
    contentPreview: {
      type: 'string',
      description: 'Node content preview',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Node metadata',
    },
  },
} as const;

export const CanvasNodeSchema = {
  type: 'object',
  required: ['type', 'data'],
  properties: {
    type: {
      description: 'Node type',
      $ref: '#/components/schemas/CanvasNodeType',
    },
    data: {
      type: 'object',
      $ref: '#/components/schemas/CanvasNodeData',
    },
  },
} as const;
