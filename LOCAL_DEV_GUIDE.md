# 本地开发环境调试指南与最佳实践

本文档旨在总结一次复杂开发环境问题的调试过程，并为项目建立一套标准、可靠的本地开发启动与重启流程，帮助开发者规避潜在的环境问题。

## 1. 问题背景

开发者在进行功能开发时，遇到以下核心问题：

-   **前端报错**：所有与大模型相关的交互都返回 `[E3001] Model provider error, please try again later` 错误。
-   **环境极其不稳定**：
    -   API 服务端口 `5800` 频繁被不明进程占用 (`EADDRINUSE`)。
    -   前端开发端口 `5173` 也被"僵尸进程"占用。
    -   偶尔重启后，模型功能恢复正常，但项目回退到了一个包含着旧历史记录和旧前端样式的"幽灵"版本。

## 2. 核心问题诊断：两个"宇宙"的冲突

经过详细排查，问题的根源是开发者电脑上同时存在两套并行的、由 Docker 管理的服务环境，我们称之为"宇宙A"和"宇宙B"。

-   **宇宙A (问题宇宙)**：
    -   **来源**：由 `deploy/docker/docker-compose.yml` 文件定义和管理。
    -   **状态**：其数据库中的模型配置已损坏。原因是其 `refly_api` 容器在某次重启后，加载了与数据库中数据加密时不一致的 `ENCRYPTION_KEY`，导致所有 API Key 无法解密。
    -   **行为**：其 `refly_api` 容器被设置为 `restart: always`，导致它不断重启并抢占 `5800` 端口，是我们看到 `EADDRINUSE` 错误的直接原因。

-   **宇宙B (幽灵宇宙 / 好的宇宙)**：
    -   **来源**：由一个更早期的、可能在其他目录或用其他命令启动的 `docker compose` 实例创建。
    -   **状态**：这是一个**功能完好**的环境快照。它的数据库、`ENCRYPTION_KEY`、`refly_api` 服务、`refly_web` 服务全部处于一个正确匹配、可正常工作的状态。
    -   **行为**：它在后台默默运行，当我们成功关闭"问题宇宙A"后，它的服务（API和Web）就会接管端口，导致项目"奇迹般地"恢复正常，但代码和数据都回退到了旧版本。

**最终结论**：我们所有的问题，都源于试图在一个被"问题宇宙A"干扰的环境中进行开发，同时又被"幽灵宇宙B"的突然出现而迷惑。

## 3. 标准开发环境启动流程

为了确保环境的**纯净、可控、且唯一**，请严格遵守以下流程。本流程的核心思想是：**只使用 Docker 提供数据库等后端依赖，而将与代码直接相关的前端和后端服务，都在本地（Local）运行。**

### 首次配置 / 环境大扫除

当您第一次配置项目，或者感觉环境混乱需要彻底清理时，请执行此流程。

1.  **强制停止所有 Docker 容器**：
    *   目的：关闭所有潜在的"问题宇宙"和"幽灵宇宙"。
    *   命令：
        ```bash
        docker stop $(docker ps -q)
        ```

2.  **清理无用的 Docker 资源 (可选，但推荐)**：
    *   目的：删除所有已停止的容器、无用的网络和悬空的数据卷，彻底释放资源。
    *   命令：
        ```bash
        docker system prune -af --volumes
        ```

3.  **仅启动后端依赖服务**：
    *   目的：使用 Docker 启动数据库、缓存、对象存储等必不可少的中间件。
    *   命令：
        ```bash
        docker compose -f deploy/docker/docker-compose.yml up -d db minio redis qdrant searxng
        ```

4.  **配置本地环境变量**：
    *   **后端配置**：确保 `apps/api/.env` 文件存在，并包含以下关键配置：
        ```dotenv
        # 数据库地址，指向 Docker 容器
        DATABASE_URL="postgresql://refly:test@localhost:35432/refly?schema=refly"
        
        # 必须设置一个确定的、32位的加密密钥，并妥善保管
        ENCRYPTION_KEY=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 # 示例，请使用您自己的
        
        # 允许本地前端开发服务访问
        ORIGIN=http://localhost:5173 
        ```
    *   **前端配置**：确保 `apps/web/.env` (或其他前端配置文件) 指向本地后端的正确地址。

5.  **启动本地开发服务 (需要两个终端)**：
    *   **终端1 (启动后端)**：
        ```bash
        # 确保位于项目根目录 /Users/longxiangyu/LexiHk/lexiAI
        pnpm dev --filter=@refly/api
        ```
    *   **终端2 (启动前端)**：
        ```bash
        # 确保位于项目根目录 /Users/longxiangyu/LexiHk/lexiAI
        pnpm dev --filter=@refly/web
        ```
        请等待终端出现 `Local: http://localhost:5173/` 的提示。

6.  **访问项目**：在浏览器中打开 `http://localhost:5173`。

### 日常开发重启流程

1.  **检查 Docker 依赖是否在运行**：
    *   命令：`docker ps`
    *   确保 `refly_db`, `refly_minio` 等容器处于 `Up` 状态。如果未运行，请执行上述**首次配置流程**的第3步。

2.  **检查并清理僵尸进程 (如有需要)**：
    *   如果发现端口被占用 (`EADDRINUSE`) 或前端无法在 `5173` 启动，说明有僵尸进程。
    *   命令 (清理前端端口)：`kill -9 $(lsof -t -i:5173)`
    *   命令 (清理后端端口)：`kill -9 $(lsof -t -i:5800)`

3.  **启动本地开发服务**：
    *   打开两个终端，分别运行命令启动后端和前端即可。

## 4. 关键问题与规避策略

-   **核心原则：保持环境单一**
    -   **永远不要**在进行本地开发时，同时通过 `docker compose up api` 或 `docker compose up web` 启动 Docker 版本的 API 和 Web 服务。这是导致所有混乱的根源。**本地开发，就只让后端依赖运行在 Docker 中。**

-   **`ENCRYPTION_KEY` 是神圣的**
    -   这个 Key 是您所有模型 API 密钥的"主密码"。一旦在生产环境或一个长期使用的开发环境中设定，就**绝对不能丢失或随意更改**。
    -   团队成员之间应共享并使用**同一个** `ENCRYPTION_KEY` 来连接同一个开发数据库。

-   **`docker ps` 是你的"照妖镜"**
    -   当感觉环境不对劲时，第一件事就是运行 `docker ps`，查看究竟有哪些容器在后台运行。这是判断是否存在"幽灵宇宙"的最快方法。

-   **CORS 跨域问题**
    -   本地前端 (`localhost:5173`) 访问本地后端 (`localhost:5800`) 属于跨域行为。后端必须在 `apps/api/.env` 的 `ORIGIN` 变量中明确授权，否则浏览器会拦截所有 API 请求。

-   **命令必须在项目根目录运行**
    -   所有 `pnpm` 命令都必须在包含根 `package.json` 的项目目录下运行，否则会报 `ERR_PNPM_NO_IMPORTER_MANIFEST_FOUND` 错误。 